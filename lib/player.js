import {canvasHeight, canvasWidth} from './util'
import { PlayerBulletBasic } from './bullet'
import MovingObject from './moving_object'
import SoundFx from './sound_fx'

const HOVER_SCALE = 1.0;

/**
 * Defines the Player object containing the ship functionality and its actions inheriting from MovingObject.
 */
class Player extends MovingObject {
  /**
   * Initializes a new instance of the Player class.  
   */
  constructor () {
    let props = {
      posX: Math.floor(canvasWidth / 2),
      posY: Math.floor(canvasHeight / 1.2)
    };

    super(props);
    this.actions = {
      moveLeft: false,
      moveRight: false,
      moveUp: false,
      moveDown: false,
      fireBullet: false
    };

    this.bulletFx = SoundFx.playerBullet;
    this.topSpeed = 5;
    this.hp = 10;
    this.bulletCooldown = 0;
    this.playerBullets = [];
    this.hitboxW = 30;
    this.hitboxH = 46;
    this.iframe = 0;
    this.playerController();
    this.useHover = false;
    this.hoverX = 0;
    this.hoverY = 0;
  }

  /**
   * Function for firing the player ship's bullet. 
   */
  fireBullet () {
    let bulletData = {
      speedX: [-1, 0, 1][Math.floor(Math.random() * 3)],
      speedY: -10,
      posX: this.posX + Math.floor(this.hitboxW / 2) - 10,
      posY: this.posY - 20
    };

    let newBullet = new PlayerBulletBasic(bulletData);
    this.playerBullets.push(newBullet);
    this.bulletCooldown = 6;
    this.bulletFx.play();
  }

  /**
   * Calculates the inertia for the player ship based on the action inputs.
   */
  calculateInertia () {
    if (this.actions.moveLeft) {
      if (Math.abs(this.speedX) < this.topSpeed) {
        this.speedX--;
      }
    } else if (this.speedX < 0) {
      this.speedX++;
    }
    if (this.actions.moveRight) {
      if (Math.abs(this.speedX) < this.topSpeed) {
        this.speedX++;
      }
    } else if (this.speedX > 0) {
      this.speedX--;
    }
    if (this.actions.moveUp) {
      if (Math.abs(this.speedY) < this.topSpeed) {
        this.speedY--;
      }
    } else if (this.speedY < 0) {
      this.speedY++;
    }
    if (this.actions.moveDown) {
      if (Math.abs(this.speedY) < this.topSpeed) {
        this.speedY++;
      }
    } else if (this.speedY > 0) {
      this.speedY--;
    }
  }

  /**
   * Defines how to player ship moves. Also checks if there is a fireBullet action to execute.
   */
  move () {
    // If iframe is 0, no invincibility. 
    this.iframe && this.iframe--;

    if (this.actions.fireBullet) {
      if (this.bulletCooldown === 0) {
        this.fireBullet();
      } else {
        this.bulletCooldown--;
      }
    }
    if (this.posX + this.speedX >= 0 && this.posX + this.speedX <= canvasWidth - this.hitboxW) {
      this.posX += this.speedX;
    }
    if (this.posY + this.speedY >= 0 && this.posY + this.speedY <= canvasHeight - this.hitboxH) {
      this.posY += this.speedY;
    }
  }

  /**
   * Cleans up exhausted bullets generated by the player ship.
   */
  deleteBullets () {
    this.playerBullets = this.playerBullets.filter(bul => !bul.cleanup);
  }

  /**
   * Calls function to clean up bullets, calculate inertia, move the player ship, and redraw the playship on the context object.  
   * @param {any} ctx
   */
  render (ctx) {
    if (this.bulletCooldown === 0) {
      this.deleteBullets();
    }

    if (this.useHover == true) {
      this.convertHoverToAction();
    }
    
    this.calculateInertia();
    this.move();
    ctx.drawImage(...this.getSprite());

    if (this.useHover == true) {
      this.resetActions();
    }
  }

  /**
   * Gets the necessary sprite based on the ship speedX (driven by inputs)
   */
  getSprite () {
    const frame = [0, 1][Math.floor(Math.random() * 2)];

    let normalSprite = [
      [this.images.playerShip, 0, 0, 32, 44, this.posX, this.posY, this.hitboxW, this.hitboxH],
      [this.images.playerShip, 32, 0, 32, 44, this.posX, this.posY, this.hitboxW, this.hitboxH]
    ];

    let leftSprite = [
      [this.images.playerShipL, 0, 0, 26, 44, this.posX, this.posY, this.hitboxW, this.hitboxH],
      [this.images.playerShipL, 26, 0, 26, 44, this.posX, this.posY, this.hitboxW, this.hitboxH]
    ];

    let rightSprite = [
      [this.images.playerShipR, 0, 0, 26, 44, this.posX, this.posY, this.hitboxW, this.hitboxH],
      [this.images.playerShipR, 26, 0, 26, 44, this.posX, this.posY, this.hitboxW, this.hitboxH]
    ];

    if (this.speedX === 0) {
      return normalSprite[frame];
    } else if (this.speedX < 0) {
      return leftSprite[frame];
    } else if (this.speedX > 0) {
      return rightSprite[frame];
    }
  }

  /**
   * Resets the player's actions... 
   */
  resetActions() {
    this.actions.moveUp = false;
    this.actions.moveRight = false;
    this.actions.moveDown = false;
    this.actions.moveLeft = false;
  }

  /**
   * Sets appropriate action for changing ship's position from hover action...
   */
  convertHoverToAction() {
    // Account for scaling of X as screen changes...
    var shipsX = Math.floor(this.posX * (document.getElementById('c-container').offsetWidth / canvasWidth));
    var shipsY = this.posY;

    if (this.hoverX < shipsX) {
      this.actions.moveLeft = true;
      //this.actions.moveRight = false;
    } 
    if (this.hoverX > shipsX) {
      this.actions.moveRight = true;
      //this.actions.moveLeft = false;
    }
    if (this.hoverY > shipsY) {
      this.actions.moveDown = true;
      //this.actions.moveUp = false;
    }
    if (this.hoverY < shipsY) {
      this.actions.moveUp = true;
      //this.actions.moveDown = false;
    }
    if (this.hoverX == shipsX ) {
      this.actions.moveRight = false;
      //this.actions.moveLeft = false;
    }
    if (this.hoverY == shipsY) {
      this.actions.moveDown = false;
      //this.actions.moveUp = false;
    }
  }

  /**
   * Set the hover coordinates from the hover events...
   * @param {any} eclientX
   * @param {any} eclientY
   */
  setHoverCoordinates(eclientX, eclientY) {
    var rect = document.getElementById('c-container').getBoundingClientRect();
    // Account of scale of Y as screen grows
    var scaleFactorY = this.getHoverScaleY();
    this.hoverX = Math.floor(eclientX - rect.left);
    this.hoverY = Math.floor((eclientY - rect.top) * scaleFactorY);
  }

  /**
   * Return the scaling of Y coordinates for the hover actions...
   */
  getHoverScaleY() {
    return canvasHeight / document.getElementById('m-container').offsetHeight;
  }

  /**
   * Defines the controller for detecting player inputs for controlling the ship.  
   * This will set a specific action to true, given the keycode to switch cases.
   */
  playerController() {
    // KEYCODES: 37: left, 38: up, 39: right, 40: down, 32: space
    // Specify flags set on keydown event.
    document.addEventListener('keydown', (e) => {    
      this.useHover = false;
      switch (e.keyCode) {
        case 65:
        case 37:
          this.actions.moveLeft = true;
          break;
        case 87:
        case 38:
          this.actions.moveUp = true;
          break;
        case 68:
        case 39:
          this.actions.moveRight = true;
          break;
        case 83:
        case 40:
          this.actions.moveDown = true;
          break;
        case 32:
          this.actions.fireBullet = true;
          break;
        default:
          break;
      }
    })

    // Specify flags set for keyup events
    document.addEventListener('keyup', (e) => {
      switch (e.keyCode) {
        case 65:
        case 37:
          this.actions.moveLeft = false;
          break;
        case 87:
        case 38:
          this.actions.moveUp = false;
          break;
        case 68:
        case 39:
          this.actions.moveRight = false;
          break;
        case 83:
        case 40:
          this.actions.moveDown = false;
          break;
        case 32:
          this.actions.fireBullet = false;
          this.bulletCooldown = 0;
          break;
        default:
          break;
      }
    })

    // Add event listener for mouse move in canvas...
    document.getElementById('c-container').addEventListener('mousemove', e => {
      // Check position of mouse in relationship to ship.
      this.useHover = true; 
      this.setHoverCoordinates(e.clientX, e.clientY);
    })
    // Add event for mouseclick to fire
    document.getElementById('c-container').addEventListener('mousedown', e => {
      this.actions.fireBullet = true;
    })
    // Add event to stop firing when mouseclick is finished
    document.getElementById('c-container').addEventListener('mouseup', e => {
      this.actions.fireBullet = false;
    })
    // Add event listener for tuch move in canvas
    document.addEventListener('touchmove', e => {
      // Check position of touch in relationship to ship.
      this.useHover = true;
      this.actions.fireBullet = true;
      this.setHoverCoordinates(e.clientX, e.clientY);
    })
    // Add event to stop firing when finger is release
    document.addEventListener('touchend', e => {
      this.useHover = false;
      this.actions.fireBullet = false;
    })
  }
}

export default Player
